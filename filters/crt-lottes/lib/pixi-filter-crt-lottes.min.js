/*!
 * pixi-filter-crt-lottes - v1.0.0
 * Compiled Tue, 12 Sep 2017 20:44:47 UTC
 *
 * Licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(e.__pixi_filter_crt_lottes={})}(this,function(e){"use strict";var n="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",t="//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//   by Timothy Lottes\n//\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n// Adopted for PIXI.js by Marek Ventur\n\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform float size;\nuniform float hardScan;\nuniform float hardPixel;\nuniform float intensity;\n\nvec2 warp =vec2(0.0, 0.0); //vec2(1.0/32.0,1.0/24.0);\n\n// Emulated input resolution.\n#define res (filterArea.xy/size/2.0)\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToLinear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nvec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToSrgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec3 Fetch(vec2 pos,vec2 off){\n  pos=floor(pos*res+off)/res;\n  return ToLinear(texture2D(uSampler,(pos.xy),-16.0).rgb);\n}\n\n// Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos){pos=pos*res;return -((pos-floor(pos))-vec2(0.5));}\n\n// 1D Gaussian.\nfloat Gaus(float pos,float scale){return exp2(scale*pos*pos);}\n\n// 3-tap Gaussian filter along horz line.\nvec3 Horz3(vec2 pos,float off){\n    vec3 b=Fetch(pos,vec2(-1.0,off));\n    vec3 c=Fetch(pos,vec2( 0.0,off));\n    vec3 d=Fetch(pos,vec2( 1.0,off));\n    float dst=Dist(pos).x;\n    // Convert distance to weight.\n    float scale=-hardPixel;\n    float wb=Gaus(dst-1.0,scale);\n    float wc=Gaus(dst+0.0,scale);\n    float wd=Gaus(dst+1.0,scale);\n    // Return filtered sample.\n    return (b*wb+c*wc+d*wd)/(wb+wc+wd);\n}\n\n// 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 pos,float off){\n    vec3 a=Fetch(pos,vec2(-2.0,off));\n    vec3 b=Fetch(pos,vec2(-1.0,off));\n    vec3 c=Fetch(pos,vec2( 0.0,off));\n    vec3 d=Fetch(pos,vec2( 1.0,off));\n    vec3 e=Fetch(pos,vec2( 2.0,off));\n    float dst=Dist(pos).x;\n    // Convert distance to weight.\n    float scale=-hardPixel;\n    float wa=Gaus(dst-2.0,scale);\n    float wb=Gaus(dst-1.0,scale);\n    float wc=Gaus(dst+0.0,scale);\n    float wd=Gaus(dst+1.0,scale);\n    float we=Gaus(dst+2.0,scale);\n    // Return filtered sample.\n    return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);\n}\n\n// Return scanline weight.\nfloat Scan(vec2 pos,float off){\n    float dst=Dist(pos).y;\n    return Gaus(dst+off,-hardScan);\n}\n\n// Allow nearest three lines to effect pixel.\nvec3 Tri(vec2 pos){\n    vec3 a=Horz3(pos,-1.0);\n    vec3 b=Horz5(pos, 0.0);\n    vec3 c=Horz3(pos, 1.0);\n    float wa=Scan(pos,-1.0);\n    float wb=Scan(pos, 0.0);\n    float wc=Scan(pos, 1.0);\n    return a*wa+b*wb+c*wc;\n}\n\nvoid main( void ){\n    gl_FragColor.rgb=Tri(vTextureCoord);\n    gl_FragColor.rgb=ToSrgb(gl_FragColor.rgb);\n    // If intensity parameter is used mix with orignal color\n    if (intensity < 1.0) {\n        vec4 original = texture2D(uSampler, vTextureCoord);\n        gl_FragColor = intensity * gl_FragColor + (1.0 - intensity) * original;\n    }\n}\n\n",o=function(e){function o(o){void 0===o&&(o={});var r=o.size;void 0===r&&(r=3);var i=o.hardScan;void 0===i&&(i=8);var s=o.hardPixel;void 0===s&&(s=3);var a=o.intensity;void 0===a&&(a=1),e.call(this,n,t),this.size=r,this.hardScan=i,this.hardPixel=s,this.intensity=a}e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o;var r={size:{},hardScan:{},hardPixel:{},intensity:{}};return r.size.get=function(){return this.uniforms.size},r.size.set=function(e){this.uniforms.size=e},r.hardScan.get=function(){return this.uniforms.hardScan},r.hardScan.set=function(e){this.uniforms.hardScan=e},r.hardPixel.get=function(){return this.uniforms.hardPixel},r.hardPixel.set=function(e){this.uniforms.hardPixel=e},r.intensity.get=function(){return this.uniforms.intensity},r.intensity.set=function(e){this.uniforms.intensity=e},Object.defineProperties(o.prototype,r),o}(PIXI.Filter);PIXI.filters.CrtLottesFilter=o,e.CrtLottesFilter=o,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=pixi-filter-crt-lottes.min.js.map
