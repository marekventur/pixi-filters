/*!
 * pixi-filter-led - v1.0.0
 * Compiled Tue, 12 Sep 2017 17:02:12 UTC
 *
 * Licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
!function(n,o){"object"==typeof exports&&"undefined"!=typeof module?o(exports):"function"==typeof define&&define.amd?define(["exports"],o):o(n.__pixi_filter_led={})}(this,function(n){"use strict";var o="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",e="precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float size;\nuniform float fill;\nuniform vec4 background;\nuniform float intensity;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // Calculate radius of LED\n    float radius = size * fill * 0.5;\n\n    // Calculate relative position to middle of LED\n    vec2 relativeDistance = coord - floor( coord / size ) * size - vec2(size / 2.0, size / 2.0);\n    float distanceSquared = relativeDistance.x * relativeDistance.x + relativeDistance.y * relativeDistance.y;\n\n    // Calculate whether pixel is part of LED or background\n    if (distanceSquared > radius * radius) {\n        gl_FragColor = background;\n    } else {\n        // Use color of pixel that would be in the middle of LED\n        coord = floor( coord / size ) * size + vec2(size / 2.0, size / 2.0);\n        coord = unmapCoord(coord);\n        gl_FragColor = texture2D(uSampler, coord);\n    }\n\n    // If intensity parameter is used mix with orignal color\n    if (intensity < 1.0) {\n        vec4 original = texture2D(uSampler, vTextureCoord);\n        gl_FragColor = intensity * gl_FragColor + (1.0 - intensity) * original;\n    }\n}\n",i=function(n){function i(i){void 0===i&&(i={});var r=i.size;void 0===r&&(r=10);var t=i.fill;void 0===t&&(t=.9);var a=i.backgroundColor;void 0===a&&(a=0);var s=i.backgroundAlpha;void 0===s&&(s=1);var u=i.intensity;void 0===u&&(u=1),n.call(this,o,e),this.uniforms.background=new Float32Array([0,0,0,1]),this.size=r,this.fill=t,this.backgroundColor=a,this.backgroundAlpha=s,this.intensity=u}n&&(i.__proto__=n),(i.prototype=Object.create(n&&n.prototype)).constructor=i;var r={size:{},fill:{},backgroundColor:{},backgroundAlpha:{},intensity:{}};return r.size.get=function(){return this.uniforms.size},r.size.set=function(n){this.uniforms.size=n},r.fill.get=function(){return this.uniforms.fill},r.fill.set=function(n){this.uniforms.fill=n},r.backgroundColor.get=function(){return PIXI.utils.rgb2hex(this.uniforms.background)},r.backgroundColor.set=function(n){PIXI.utils.hex2rgb(n,this.uniforms.background)},r.backgroundAlpha.get=function(){return this.uniforms.background[3]},r.backgroundAlpha.set=function(n){this.uniforms.background[3]=Math.min(1,Math.max(0,n))},r.intensity.get=function(){return this.uniforms.intensity},r.intensity.set=function(n){this.uniforms.intensity=n},Object.defineProperties(i.prototype,r),i}(PIXI.Filter);PIXI.filters.LedFilter=i,n.LedFilter=i,Object.defineProperty(n,"__esModule",{value:!0})});
//# sourceMappingURL=pixi-filter-led.min.js.map
